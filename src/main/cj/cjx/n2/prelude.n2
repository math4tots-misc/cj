
template[T] void print(t: T) = js!(void, "console.log(''+", t.str(), ")")

unreachable panic(s: str) = js!(unreachable, "panic(", s, ")")

bool __is(a: var, b: var) = js!(bool, a, "===", b)

template[T] void print2(t: T) {
    js!(void, "console.log(''+", t, ")")
}

int __checkIndex(xs: var, i: int) {
    int len = js!(int, xs, ".length")
    if (i < 0) i = i + len
    if (i < 0 || i >= len) panic("Index out of bounds (i = " + i.repr() + ", len = " + len.repr() + ")")
    i
}

// ============================================================
//     any
// ============================================================
trait any
str any.json(self: var) = js!(str, "JSON.stringify(", self, ")")
str any.str(self: var) = repr()
str any.repr(self: var) = json()

// ============================================================
//     int
// ============================================================
str int.str(self: int) = self.repr()
str int.repr(self: int) = js!(str, "''+", self)

// ============================================================
//     str
// ============================================================
int str.len(s: str) = js!(int, s, ".length")
str str.str(s: str) = s
str str.repr(s: str) = js!(str, "JSON.stringify(", s, ")")
int str.get(s: str, i: int) = js!(int, s, ".charCodeAt(", i, ")")

// ============================================================
//     list
// ============================================================
template[T] int list.len(self: T[]) = js!(int, self, ".length")
template[T] void list.add(self: T[], t: T) = js!(void, self, ".push(", t, ")")
template[T] T list.get(self: T[], i: int) = js!(T, self, "[", __checkIndex(self, i), "]")
template[T] str list.str(self: T[]) = self.repr()
template[T] str list.repr(self: T[]) {
    auto sb = StringBuilder.new()
    sb.add("[")
    for (int i = 0; i < self.len(); i++) {
        if (i) sb.add(", ")
        sb.add(get(i).repr())
    }
    sb.add("]")
    sb.str()
}

// ============================================================
//     StringBuilder
// ============================================================
struct StringBuilder native {}
StringBuilder StringBuilder.new() = js!(StringBuilder, "[]")
template[T] void StringBuilder.add(self: StringBuilder, t: T) = js!(
    void, self, ".push(", t.str(), ")")
str StringBuilder.str(self: StringBuilder) = js!(str, self, ".join('')")

// ============================================================
//     Tuple
// ============================================================
template[T0, T1] struct Tuple2 {
    T0 f0
    T1 f1
}
template[T0, T1, T2] struct Tuple3 {
    T0 f0
    T1 f1
    T2 f2
}

// ============================================================
//     Map
// ============================================================
template[K, V] struct Map {
    null[Tuple2[K, V]][] _entries
    int _size
}
template[K, V] Map[K, V] Map.empty() = Map[K, V]([], 0)
template[K, V] str Map.str(self: Map[K, V]) = repr()
template[K, V] str Map.repr(self: Map[K, V]) = "Map()"
template[K, V] int Map.size(self: Map[K, V]) = _size
int Map._getIndex(hash: int, size: int) = (hash % size + size) % size
template[K, V]
void Map._insertNoRehash(self: Map[K, V], triple: Tuple3[int, K, V]) {
    auto hash = triple.f0
    auto key = triple.f1
    auto list = _entries
    auto index = _getIndex(hash, _size)
    auto bucket = list[index]
    for (i = 0; i < bucket.size(); i++) {
        auto entry = bucket[i]
        if (entry.f0 == hash && entry.f1 == key) {
            bucket[i] = triple
            return ()
        }
    }
    _size = _size + 1
    bucket.add(triple)
}
