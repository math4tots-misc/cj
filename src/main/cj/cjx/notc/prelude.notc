
// TODO: these values in memory need to be initialized before main starts
const __HEAP_START_REF = 8
const __HEAP_END_REF = 12
const __HEAP_FREELIST_START = 16

int __heap_start() = load!(__HEAP_START_REF)
int __heap_end() = load!(__HEAP_END_REF)
int __heap_freelist_get(int index) = load!(__HEAP_FREELIST_START + 4 * index)
int __heap_freelist_set(int index, int ptr) = store!(__HEAP_FREELIST_START + 4 * index, ptr)
int __heap_alloc(int size) {
    // 'size' must be a multiple of 8
    int ptr = load!(__HEAP_END_REF)
    store!(__HEAP_END_REF, ptr + size)
    ptr
}

// Malloc will return a pointer to a memory block with (askSize + 8) bytes
//   * first 4 bytes is the reference count,
//   * next 4 bytes is ~(log2(askSize) - 3)
//   * remaining bytes is user data
int __malloc(int askSize) {
    int reqSize = askSize + 8 // 8 byte header
    int size = 8
    int log2 = 0
    while (size < reqSize) {
        size = size * 2
        log2 = log2 + 1
    }
    if (log2 > 30) {
        // TODO: panic here, out of memory
    }

    int freelistptr = __HEAP_FREELIST_START + 4 * log2

    int freelist = load!(freelistptr)

    if (freelist) {
        // freelists contain:
        //    * first 4 bytes is the pointer to the next entry in the freelist
        //    * garbage data
        int nextPtr = load!(freelistptr)
        store!(freelistptr, nextPtr)
        store!(freelist,        1) // reference count
        store!(freelist + 4, log2) // store reserved size (~log2)
        freelist
    } else {
        // there's nothing in the freelist, so we need to allocate some fresh data
        __heap_alloc(size)
    }

    int ptr = __heap_alloc(size + 8)
    store!(ptr, 1)
    store!(ptr, size)
    ptr + 8
}

void __free(int ptr) {
    // add the given block to the freelist
    // a freelist block's memory looks like:
    //   * first 4 bytes is a pointer to the next entry in the freelist
    //   * rest of the bytes is garbage
    int log2 = load!(ptr + 4)
    int freelistptr = __HEAP_FREELIST_START + 4 * log2
    int nextPtr = load!(freelistptr)
    store!(ptr, nextPtr)
    store!(freelistptr, ptr)
}
